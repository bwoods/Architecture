use std::cell::RefCell;
use std::collections::VecDeque;
use std::fmt::Debug;
use std::rc::Rc;
use std::time::{Duration, Instant};

use futures::executor::LocalPool;
use futures::Stream;

use clock::TestClock;

use crate::effects::{Delay, Effects, Queue, Scheduler};
use crate::reducer::Reducer;
use crate::Task;

mod clock;

#[doc = include_str!("README.md")]
pub struct TestStore<State: Reducer>
where
    <State as Reducer>::Action: Debug,
{
    state: Option<State>, // `Option` so that `into_inner` does not break `Drop`
    inner: Rc<RefCell<Inner<<State as Reducer>::Action>>>,
}

impl<State: Reducer> Default for TestStore<State>
where
    State: Default,
    <State as Reducer>::Action: Debug,
{
    fn default() -> Self {
        Self::new(|| State::default())
    }
}

impl<State: Reducer> Drop for TestStore<State>
where
    <State as Reducer>::Action: Debug,
{
    #[track_caller]
    fn drop(&mut self) {
        assert!(
            self.inner.borrow().effects.is_empty(),
            "one or more extra actions were not tested for: {:#?}",
            self.inner
                .borrow_mut()
                .effects
                .drain(..)
                .collect::<Vec<_>>()
        );
    }
}

impl<State: Reducer> TestStore<State>
where
    <State as Reducer>::Action: Debug,
{
    /// Creates a new `Store` with `state` as its initial state.
    pub fn with_initial(state: State) -> Self {
        Self {
            state: Some(state),
            inner: Default::default(),
        }
    }

    /// Creates a new `Store` with its initial state generated by a function.
    pub fn new<F>(with: F) -> Self
    where
        F: (FnOnce() -> State),
    {
        Self::with_initial(with())
    }

    /// Calls the `Store`’s [`Reducer`][`crate::Reducer`] with `action` and asserts the
    /// expected state changes.
    #[track_caller]
    pub fn send(&mut self, action: <State as Reducer>::Action, assert: impl FnOnce(&mut State))
    where
        State: Clone + Debug + PartialEq,
        <State as Reducer>::Action: 'static,
    {
        let mut expected = self.state.clone();
        assert(expected.as_mut().unwrap());

        assert!(
            self.inner.borrow().effects.is_empty(),
            "an extra action was received: {:#?}",
            self.inner
                .borrow_mut()
                .effects
                .drain(..)
                .collect::<Vec<_>>()
        );

        self.state
            .as_mut()
            .unwrap()
            .reduce(action, self.inner.clone());
        assert_eq!(self.state, expected);
    }

    /// Checks that the `Store`’s [`Reducer`][`crate::Reducer`] was called with `action`
    /// and asserts the expected state changes.
    #[track_caller]
    pub fn recv(&mut self, action: <State as Reducer>::Action, assert: impl FnOnce(&mut State))
    where
        State: Clone + Debug + PartialEq,
        <State as Reducer>::Action: Debug + PartialEq + 'static,
    {
        let mut expected = self.state.clone();
        assert(expected.as_mut().unwrap());

        let received = self
            .inner
            .borrow_mut()
            .effects
            .pop_front()
            .expect("no action received");
        assert_eq!(received, action);

        self.state
            .as_mut()
            .unwrap()
            .reduce(action, self.inner.clone());
        assert_eq!(self.state, expected);
    }

    /// Waits until all scheduled tasks have completed.
    ///
    /// A timeout should be added to the unit test to ensure that it does not
    /// wait forever if there are bugs in the asynchronous tasks.
    ///
    /// The ntest framework provides a [#[timeout]][timeout] attribute macro
    /// for example.
    ///
    /// [timeout]: (https://docs.rs/ntest/latest/ntest/attr.timeout.html)
    pub fn wait(&mut self) {
        self.inner.borrow_mut().pool.run()
    }

    /// Consumes the `Store` and returns its current `state` value.
    pub fn into_inner(mut self) -> <State as Reducer>::Output
    where
        State: Into<<State as Reducer>::Output>,
    {
        self.state.take().unwrap().into()
    }
}

/// Shared between [`TestStore`] and [`TestClock`]

struct Inner<Action> {
    effects: VecDeque<Action>,
    queue: Queue<Instant, Action>,

    pool: LocalPool,
    now: Instant,
}

impl<Action> Effects for Rc<RefCell<Inner<Action>>>
where
    Action: Debug + 'static,
{
    type Action = Action;

    fn send(&self, action: impl Into<<Self as Effects>::Action>) {
        self.borrow_mut().effects.push_back(action.into());
    }

    fn task<S: Stream<Item = <Self as Effects>::Action> + 'static>(&self, _stream: S) -> Task {
        todo!()
    }
}

impl<Action> Scheduler for Rc<RefCell<Inner<Action>>>
where
    Action: Debug + 'static,
{
    type Action = Action;

    fn now(&self) -> Instant {
        self.borrow().now
    }

    fn schedule(
        &self,
        _action: Self::Action,
        _after: impl IntoIterator<Item = Delay> + 'static,
    ) -> Task
    where
        Self::Action: Clone + 'static,
    {
        todo!()
    }
}

impl<Action> TestClock for Rc<RefCell<Inner<Action>>> {
    fn advance(&self, duration: Duration) {
        use std::ops::Deref;

        let inner = &mut *self.deref().borrow_mut();
        inner.now += duration;

        let effects = &mut inner.effects;
        effects.extend(inner.queue.drain_until(inner.now));
    }
}

impl<Action> Default for Inner<Action> {
    fn default() -> Self {
        Self {
            effects: Default::default(),
            queue: Default::default(),
            pool: Default::default(),
            now: Instant::now().into(),
        }
    }
}
