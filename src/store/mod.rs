use std::thread::{JoinHandle, Thread};

use flume::Sender;

use crate::Reducer;

mod runtime;

#[cfg(feature = "blocking")]
mod blocking;
pub(crate) mod testing;

#[doc = include_str!("README.md")]
pub struct Store<State: Reducer> {
    sender: Sender<Result<<State as Reducer>::Action, Thread>>,
    handle: JoinHandle<<State as Reducer>::Output>,
}

impl<State: Reducer> Store<State> {
    /// Creates a new `Store` with `state` as its initial state.
    ///
    /// If `State` is not [`Send`], then [`new`][`Store::new`] or [`default`][`Store::default`]
    /// can be used instead.
    pub fn with_initial(state: State) -> Self
    where
        State: Send + 'static,
        <State as Reducer>::Action: Send,
        <State as Reducer>::Output: Send + From<State>,
    {
        Store::runtime(|| state)
    }

    /// Creates a new `Store` with its initial state generated by a function.
    ///
    /// Useful if `State` is not [`Send`], but the arguments used to construct it are.
    pub fn new<F>(with: F) -> Self
    where
        F: (FnOnce() -> State) + Send + 'static,
        <State as Reducer>::Action: Send + 'static,
        <State as Reducer>::Output: Send + From<State> + 'static,
    {
        Store::runtime(with)
    }

    /// Calls the `Store`’s [`Reducer`][`crate::Reducer`] with `action`.
    ///
    /// Takes an [`Into<Action>`] so that both child and parent `Action`s may be sent easily.
    pub fn send(&self, action: impl Into<<State as Reducer>::Action>) {
        self.sender.send(Ok(action.into())).expect("send")
    }

    /// Stops the `Store`’s runtime and returns its current `state` value.  
    ///
    /// # Note
    /// Care should be exercised when using this method in applications that utilize
    /// asynchronous [`Effects`][`crate::effects::Effects`]. `into_inner` makes a “best effort”
    /// to wait until any pending tasks are completed but it is not guaranteed.
    pub fn into_inner(self) -> <State as Reducer>::Output {
        self.sender
            .send(Err(std::thread::current()))
            .expect("into_inner");
        std::thread::park(); // waiting for any async tasks to finish up

        drop(self.sender); // ends the runtime’s (outer) while-let
        self.handle.join().unwrap()
    }

    #[cfg(feature = "blocking")]
    /// Creates a special “blocking” `Store` that does *not* isolate its actions on it own thread.
    /// This lack of isolation has consequences.
    ///   - This `Store`’s `send` requires a mutable `self` (exclusive access) to send actions
    ///     through the reducer.
    ///   - This `Store`’s reducer will block the calling thread for as long as actions are running
    ///     whenever it receives a `send`.
    ///   - As there is no dedicated thread, no progress will be made on `async` work unless there
    ///     are a continuous stream of actions flowing through the `Store`.
    ///
    ///  The main use of this constructor is for interfacing with libraries that require that they
    ///  are always called in the main thread.
    pub fn blocking(state: State) -> blocking::Store<State> {
        blocking::Store::with_initial(state)
    }
}

impl<State: Reducer> Default for Store<State>
where
    State: Default,
    <State as Reducer>::Action: Send + 'static,
    <State as Reducer>::Output: Send + From<State> + 'static,
{
    /// Creates a new `Store` with a default initial state.
    fn default() -> Self {
        Store::new(|| State::default())
    }
}
