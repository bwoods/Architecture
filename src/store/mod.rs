use std::thread::{JoinHandle, Thread};

use flume::Sender;

use crate::reducer::Reducer;

mod runtime;

pub(crate) mod testing;

#[doc = include_str!("README.md")]
pub struct Store<State: Reducer> {
    sender: Sender<Result<<State as Reducer>::Action, Thread>>,
    handle: JoinHandle<<State as Reducer>::Output>,
}

impl<State: Reducer> Store<State> {
    /// Creates a new `Store` with `state` as its initial state.
    ///
    /// If `State` is not [`Send`], then [`new`][`Store::new`] or [`default`][`Store::default`]
    /// can be used instead.
    pub fn with_initial(state: State) -> Self
    where
        State: Send + 'static,
        <State as Reducer>::Action: Send,
        <State as Reducer>::Output: Send,
    {
        Store::runtime(|| state)
    }

    /// Creates a new `Store` with its initial state generated by a function.
    ///
    /// Useful if `State` is not [`Send`], but the arguments used to construct it are.
    pub fn new<F>(with: F) -> Self
    where
        F: (FnOnce() -> State) + Send + 'static,
        <State as Reducer>::Action: Send + 'static,
        <State as Reducer>::Output: Send + 'static,
    {
        Store::runtime(with)
    }

    pub fn send(&self, action: impl Into<<State as Reducer>::Action>) {
        self.sender.send(Ok(action.into())).expect("Store::send")
    }

    /// Stops the `Store`’s runtime and returns its current `state` value.  
    ///
    /// # Note
    /// Care should be exercised when using this method in applications that utilize
    /// asynchronous [`Effects`][`crate::effects::Effects`]. `into_inner` makes a “best effort”
    /// to wait until any pending tasks are completed but it is not guaranteed.
    pub fn into_inner(self) -> <State as Reducer>::Output {
        self.sender
            .send(Err(std::thread::current()))
            .expect("Store::into_inner");
        std::thread::park(); // waiting for any async tasks to finish up

        drop(self.sender); // ends the runtime’s (outer) while-let
        self.handle.join().unwrap()
    }
}

impl<State: Reducer> Default for Store<State>
where
    State: Default,
    <State as Reducer>::Action: Send + 'static,
    <State as Reducer>::Output: Send + 'static,
{
    /// Creates a new `Store` with a default initial state.
    fn default() -> Self {
        Store::new(|| State::default())
    }
}
